Let's start with the backend part of the project. We will use GoLang for the backend and MySQL for the database. We will use the `gin-gonic/gin` package for creating the REST API and `go-sql-driver/mysql` for connecting to the MySQL database.

backend/main.go
```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

type User struct {
	gorm.Model
	Name  string `json:"name"`
	Email string `gorm:"type:varchar(100);unique_index" json:"email"`
}

var db *gorm.DB

func main() {
	var err error
	db, err = gorm.Open("mysql", "root:root@/dbname?charset=utf8&parseTime=True&loc=Local")
	if err != nil {
		panic("failed to connect database")
	}
	defer db.Close()

	db.AutoMigrate(&User{})

	r := gin.Default()

	v1 := r.Group("/api/v1")
	{
		v1.GET("/users", GetUsers)
		v1.GET("/users/:id", GetUser)
		v1.POST("/users", CreateUser)
		v1.PUT("/users/:id", UpdateUser)
		v1.DELETE("/users/:id", DeleteUser)
	}

	r.Run()
}

func GetUsers(c *gin.Context) {
	var users []User
	if err := db.Find(&users).Error; err != nil {
		c.AbortWithStatus(404)
	} else {
		c.JSON(200, users)
	}
}

func GetUser(c *gin.Context) {
	id := c.Params.ByName("id")
	var user User
	if err := db.Where("id = ?", id).First(&user).Error; err != nil {
		c.AbortWithStatus(404)
	} else {
		c.JSON(200, user)
	}
}

func CreateUser(c *gin.Context) {
	var user User
	c.BindJSON(&user)

	if err := db.Create(&user).Error; err != nil {
		c.AbortWithStatus(404)
	} else {
		c.JSON(200, user)
	}
}

func UpdateUser(c *gin.Context) {
	id := c.Params.ByName("id")
	var user User
	if err := db.Where("id = ?", id).First(&user).Error; err != nil {
		c.AbortWithStatus(404)
	} else {
		c.BindJSON(&user)
		db.Save(&user)
		c.JSON(200, user)
	}
}

func DeleteUser(c *gin.Context) {
	id := c.Params.ByName("id")
	var user User
	d := db.Where("id = ?", id).Delete(&user)
	c.JSON(200, gin.H{"id #" + id: "deleted"})
}
```

Now, let's move on to the frontend part of the project. We will use Vue.js for the frontend.

frontend/src/App.vue
```vue
<template>
  <div id="app">
    <UserList />
  </div>
</template>

<script>
import UserList from './components/UserList.vue'

export default {
  name: 'App',
  components: {
    UserList
  }
}
</script>

<style>
#app {
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```

frontend/src/components/UserList.vue
```vue
<template>
  <div>
    <h1>User List</h1>
    <div v-for="user in users" :key="user.id">
      <p>{{ user.name }} - {{ user.email }}</p>
    </div>
  </div>
</template>

<script>
import axios from 'axios'

export default {
  data () {
    return {
      users: []
    }
  },
  created () {
    axios.get('http://localhost:8080/api/v1/users')
      .then(response => {
        this.users = response.data
      })
  }
}
</script>
```

Now, let's create the Dockerfiles for the backend and frontend.

docker/backend/Dockerfile
```dockerfile
FROM golang:1.16

WORKDIR /app

COPY go.mod go.sum ./

RUN go mod download

COPY . .

RUN go build -o main .

EXPOSE 8080

CMD ["./main"]
```

docker/frontend/Dockerfile
```dockerfile
FROM node:14

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

RUN npm run build

EXPOSE 8081

CMD ["npm", "run", "serve"]
```

Now, let's create the docker-compose.yml file.

docker-compose.yml
```yaml
version: '3'
services:
  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: dbname
    ports:
      - "3306:3306"
  backend:
    build: ./docker/backend
    ports:
      - "8080:8080"
    depends_on:
      - db
  frontend:
    build: ./docker/frontend
    ports:
      - "8081:8081"
    depends_on:
      - backend
```

Finally, let's create the README.md file.

README.md
```markdown
# Web Application

This is a web application with a GoLang backend, MySQL database, and Vue.js frontend. It runs inside Docker containers using docker-compose.

## How to Build and Run

1. Install Docker and Docker Compose.
2. Clone this repository.
3. Navigate to the root directory of the project.
4. Run `docker-compose up --build`.

The application will be available at `http://localhost:8081`.
```

This concludes a fully working implementation.